;;;
;;; Group Theory
;;;
(define $group (set G.element))

(define $G.element (list integer))

;;
;; Basic operations
;;
(define $G.id
  (lambda [$n]
    (between 1 n)))

(define $G.*
  (lambda [$e1 $e2]
    (map (nth $ e1) e2)))

(define $G.power
  (lambda [$e $n]
    (if (eq? n 1)
      e
      (G.* (G.power e (- n 1)) e))))

(define $G.reverse
  (lambda [$e]
    (map 2#%1
         (qsort/fn 2#(compare (2#%2 %1) (2#%2 %2))
                   (zip (G.id (length e)) e)))))

(define $G.eq? (eq?/m group $ $))

(define $G.id?
  (lambda [$e]
    (eq? e (G.id (length e)))))

(define $G.group?
  (lambda [$g]
    (all id
         (match-all g group
           [<cons $e1 <cons $e2 _>>
            (member? (G.* e1 e2) g)]))))

;;
;; Symmetric groups
;;
(define $symmetric-group
  (lambda [$n]
    (match-all (between 1 n) (multiset integer)
      [(loop $i [1 n] <cons $a_i ...> <nil>)
       (map (lambda [$i] a_i) (between 1 n))])))

(define $s3 (symmetric-group 3))
(define $s4 (symmetric-group 4))
(define $s5 (symmetric-group 5))

(define $a3 (commutator-subgroup s3))
(define $a4 (commutator-subgroup s4))

(define $v4 (commutator-subgroup a4))

;;
;; Normal groups
;;
(define $normal-subgroup?
  (lambda [$h $g]
    (all id
         (map (lambda [$x]
                (G.eq? (map (G.* x $) h)
                       (map (G.* $ x) h)))
              g))))

;;
;; Cyclic groups
;;
(define $gen-cyclic-group
  (lambda [$e]
    (until-by (G.id? $) (map (G.power e $) nats))))

(define $cyclic-subgroups
  (lambda [$g]
    (unique/m group
              (map (gen-cyclic-group $)
                   g))))

(define $generators
  (lambda [$g]
    (map car (cyclic-subgroups g))))

(define $gen-group
  (lambda [$es]
    (let {[$es2 (unique (match-all es group [<cons $e1 <cons $e2 _>> (G.* e1 e2)]))]}
      (if (eq? (length es) (length es2))
        es
        (gen-group es2)))))

;;
;; Group Binary Operation
;;
(define $G.product
  (lambda [$g1 $g2]
    (unique (match-all [g1 g2] [group group]
              [[<cons $e1 _> <cons $e2 _>] (G.* e1 e2)]))))

(define $G.**
  (lambda [$g1 $g2]
    (gen-group (unique {@g1 @g2}))))

(define $G.//
  (lambda [$g1 $g2]
    (let {[$hs (difference/m (multiset G.element) (cyclic-subgroups g1) (cyclic-subgroups g2))]}
      (car (concat (map (lambda [$h]
                          (let {[$g2' (G.** h g2)]}
                            (if (include?/m (multiset G.element) g1 g2')
                              (if (include?/m (multiset G.element) g2' g1)
                                {h}
                                {(G.** h (G.// g1 g2'))})
                              {})))
                        hs))))))

;;
;; Commutator
;;
(define $commutator
  (lambda [$e1 $e2]
    (G.* (G.* (G.reverse e1) (G.reverse e2))
         (G.* e1 e2))))

(define $commutator-subgroup
  (lambda [$g]
    (gen-group (unique (match-all g group
                         [<cons $e1 <cons $e2 _>> (commutator e1 e2)])))))

;;
;; Predicate on commutativity
;;
(define $abelian-group?
  (lambda [$g]
    (eq? 1
         (length (commutator-subgroup g)))))

(define $perfect-group?
  (lambda [$g]
    (eq? (length g)
         (length (commutator-subgroup g)))))
